import { serverSupabaseClient } from "#supabase/server";
import Razorpay from "razorpay";
import crypto from "crypto";

export default defineEventHandler(async (event) => {
	const client = await serverSupabaseClient(event);
	const body = await readBody(event);

	const { razorpay_order_id, razorpay_payment_id, razorpay_signature } = body;

	if (!razorpay_order_id || !razorpay_payment_id || !razorpay_signature) {
		throw createError({
			statusCode: 400,
			statusMessage: "Missing payment information in request body",
		});
	}

	// The signature is generated by creating a HMAC-SHA256 hash.
	// The string to be hashed is the order_id + "|" + payment_id.
	const generated_signature = crypto
		.createHmac("sha256", process.env.RAZORPAY_SECRET)
		.update(razorpay_order_id + "|" + razorpay_payment_id)
		.digest("hex");

	if (generated_signature !== razorpay_signature) {
		console.error(
			"Signature verification failed. Generated vs Received:",
			generated_signature,
			razorpay_signature
		);
		throw createError({
			statusCode: 400,
			statusMessage: "Payment verification failed: Invalid signature.",
		});
	}

	// If signatures match, update the order in your database.
	const { error: updateError } = await client
		.from("orders")
		.update({
			payment_status: "paid",
			razorpay_payment_id: razorpay_payment_id,
		})
		.eq("razorpay_order_id", razorpay_order_id);

	if (updateError) {
		console.error("Error updating order status:", updateError);
		// Even if the DB update fails, the payment was successful.
		// Handle this case, e.g., by logging it for manual intervention.
		throw createError({
			statusCode: 500,
			statusMessage:
				"Payment verified but failed to update order status.",
		});
	}

	console.log("--- Verification Successful ---");

	return { success: true, orderId: razorpay_order_id };
});
